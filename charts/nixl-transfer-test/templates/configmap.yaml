---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nixl-test-script-{{ .Values.testId }}
  namespace: {{ .Values.namespace }}
  labels:
    app: nixl-transfer-test
    test-id: "{{ .Values.testId }}"
data:
  target-entrypoint.sh: |-
    #!/bin/bash
    set -e
    echo "Starting NIXL target on node ${NODE_NAME}"
    echo "Python environment check:"
    which python3
    python3 --version
    echo "Checking installed packages:"
    pip list 2>/dev/null | grep -i nixl || echo "Warning: NIXL not found in pip list"
    echo "NIXL module contents:"
    python3 -c "import nixl; print([x for x in dir(nixl) if not x.startswith('_')])" || echo "Error: Cannot inspect nixl"

    echo "Network configuration:"
    ip addr show

    echo "RDMA devices:"
    ls -la /dev/infiniband/ || echo "No infiniband devices found"

    echo "Starting NIXL target script..."
    {{ .Values.pythonPath | default "python3" }} -u /opt/nixl-test/nixl-transfer-test.py target 0.0.0.0 18515 2>&1 || echo "Python script failed with exit code: $?"

  initiator-entrypoint.sh: |-
    #!/bin/bash
    set -e
    echo "Starting NIXL initiator on node ${NODE_NAME}"
    echo "Python environment check:"
    which python3
    python3 --version
    echo "Checking installed packages:"
    pip list 2>/dev/null | grep -i nixl || echo "Warning: NIXL not found in pip list"
    echo "NIXL module contents:"
    python3 -c "import nixl; print([x for x in dir(nixl) if not x.startswith('_')])" || echo "Error: Cannot inspect nixl"

    echo "Network configuration:"
    ip addr show

    echo "RDMA devices:"
    ls -la /dev/infiniband/ || echo "No infiniband devices found"

    echo "Waiting 20 seconds for target to be ready..."
    sleep 20

    echo "Starting NIXL initiator script..."
    {{ .Values.pythonPath | default "python3" }} -u /opt/nixl-test/nixl-transfer-test.py initiator "${TARGET_HOST}" "${TARGET_PORT}" 2>&1 || echo "Python script failed with exit code: $?"

    echo "NIXL transfer test completed"

  nixl-transfer-test.py: |-
    #!/usr/bin/env python3
    """
    NIXL two-node GPU data transfer test
    Based on: https://github.com/ai-dynamo/nixl/blob/main/examples/python/blocking_send_recv_example.py
    """

    import sys
    import time
    import os

    # force unbuffered output
    sys.stdout.reconfigure(line_buffering=True)
    sys.stderr.reconfigure(line_buffering=True)

    print(">>> Python script starting...", flush=True)

    import torch
    print(f">>> PyTorch imported, CUDA available: {torch.cuda.is_available()}", flush=True)

    if torch.cuda.is_available():
        # force CUDA context creation BEFORE UCX/NIXL init
        # UCX needs an active context to detect NVLink fabric
        torch.cuda.init()
        torch.cuda.set_device(0)
        # allocate a small tensor to force context creation
        _ctx_init = torch.zeros(1, device="cuda:0")
        torch.cuda.synchronize()

        print(f">>> CUDA context created on device 0", flush=True)
        print(f">>> GPU: {torch.cuda.get_device_name(0)}", flush=True)
        print(f">>> CUDA version: {torch.version.cuda}", flush=True)

        # check P2P capabilities
        if torch.cuda.device_count() > 1:
            for i in range(torch.cuda.device_count()):
                for j in range(torch.cuda.device_count()):
                    if i != j:
                        can_p2p = torch.cuda.can_device_access_peer(i, j)
                        print(f">>> GPU {i} -> GPU {j} P2P: {can_p2p}", flush=True)

        torch.set_default_device("cuda:0")
        print(f">>> Set default device to cuda:0", flush=True)

        # del the temp tensor but keep context alive
        del _ctx_init

    from nixl._api import nixl_agent, nixl_agent_config
    print(">>> NIXL imported successfully", flush=True)

    import logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        stream=sys.stdout
    )
    logger = logging.getLogger(__name__)


    def run_target(listen_port: int):
        """run the target (server) side"""
        logger.info(f"=== TARGET MODE on port {listen_port} ===")

        # log UCX config
        ucx_vars = {k: v for k, v in os.environ.items() if k.startswith('UCX_')}
        logger.info(f"UCX config: {ucx_vars}")

        # create agent with listen port
        config = nixl_agent_config(True, True, listen_port)
        agent = nixl_agent("target", config)
        logger.info("Agent created")

        # allocate test data (100MB of ones)
        test_size = 100 * 1024 * 1024
        num_elements = test_size  # uint8 = 1 byte each
        tensors = [torch.ones(num_elements, dtype=torch.uint8)]
        logger.info(f"Allocated {test_size // (1024*1024)} MB buffer, sum={tensors[0].sum().item()}")

        # register memory
        reg_descs = agent.register_memory(tensors)
        if not reg_descs:
            logger.error("Memory registration failed")
            sys.exit(1)
        logger.info("Memory registered")

        # get trimmed descriptors for transfer
        target_descs = reg_descs.trim()
        target_desc_str = agent.get_serialized_descs(target_descs)
        logger.info(f"Got serialized descriptors ({len(target_desc_str)} bytes)")

        # wait for initiator metadata
        logger.info("Waiting for initiator metadata...")
        while not agent.check_remote_metadata("initiator"):
            time.sleep(0.1)
        logger.info("Initiator metadata received")

        # send descriptors to initiator
        agent.send_notif("initiator", target_desc_str)
        logger.info("Sent descriptors to initiator")

        # wait for transfer completion
        logger.info("Waiting for transfer to complete...")
        while not agent.check_remote_xfer_done("initiator", b"XFER"):
            time.sleep(0.1)
        logger.info("Transfer complete notification received")

        agent.deregister_memory(reg_descs)
        logger.info("=== TARGET DONE ===")
        sys.stdout.flush()
        os._exit(0)


    def run_initiator(target_host: str, target_port: int):
        """run the initiator (client) side"""
        import socket as sock_lib

        # resolve hostname to IP (NIXL requires raw IP, not DNS names)
        try:
            target_ip = sock_lib.gethostbyname(target_host)
            logger.info(f"Resolved {target_host} -> {target_ip}")
        except sock_lib.gaierror as e:
            logger.error(f"Failed to resolve {target_host}: {e}")
            sys.exit(1)

        logger.info(f"=== INITIATOR MODE connecting to {target_ip}:{target_port} ===")

        # log UCX config
        ucx_vars = {k: v for k, v in os.environ.items() if k.startswith('UCX_')}
        logger.info(f"UCX config: {ucx_vars}")

        # create agent (port 0 = ephemeral)
        config = nixl_agent_config(True, True, 0)
        agent = nixl_agent("initiator", config)
        logger.info("Agent created")

        # allocate receive buffer (100MB of zeros)
        test_size = 100 * 1024 * 1024
        num_elements = test_size
        tensors = [torch.zeros(num_elements, dtype=torch.uint8)]
        logger.info(f"Allocated {test_size // (1024*1024)} MB buffer, sum={tensors[0].sum().item()}")

        # register memory
        reg_descs = agent.register_memory(tensors)
        if not reg_descs:
            logger.error("Memory registration failed")
            sys.exit(1)
        logger.info("Memory registered")

        # fetch target metadata
        logger.info(f"Fetching target metadata from {target_ip}:{target_port}...")
        agent.fetch_remote_metadata("target", target_ip, target_port)

        # send our metadata to target
        agent.send_local_metadata(target_ip, target_port)
        logger.info("Sent local metadata")

        # wait for target's descriptors via notification
        logger.info("Waiting for target descriptors...")
        notifs = agent.get_new_notifs()
        while len(notifs) == 0:
            time.sleep(0.1)
            notifs = agent.get_new_notifs()

        target_descs = agent.deserialize_descs(notifs["target"][0])
        initiator_descs = reg_descs.trim()
        logger.info("Got target descriptors")

        # ensure metadata exchange complete
        while not agent.check_remote_metadata("target"):
            time.sleep(0.1)
        logger.info("Metadata exchange complete")

        # initialize transfer
        logger.info("Initializing transfer...")
        xfer_handle = agent.initialize_xfer(
            "READ", initiator_descs, target_descs, "target", "XFER"
        )
        if not xfer_handle:
            logger.error("Failed to create transfer")
            sys.exit(1)

        # execute transfer
        start_time = time.time()
        state = agent.transfer(xfer_handle)
        if state == "ERR":
            logger.error("Transfer failed to start")
            sys.exit(1)
        logger.info(f"Transfer started, state={state}")

        # wait for completion
        while True:
            state = agent.check_xfer_state(xfer_handle)
            if state == "ERR":
                logger.error("Transfer error")
                sys.exit(1)
            elif state == "DONE":
                break
            time.sleep(0.01)

        elapsed = time.time() - start_time
        bandwidth = (test_size / (1024**3)) / elapsed

        # verify data
        actual_sum = tensors[0].sum().item()
        expected_sum = num_elements  # all ones
        logger.info(f"Transfer done in {elapsed:.3f}s, bandwidth={bandwidth:.2f} GB/s")
        logger.info(f"Data sum: {actual_sum} (expected {expected_sum})")

        if actual_sum == expected_sum:
            logger.info("SUCCESS: Data verified!")
        else:
            logger.error("FAILED: Data mismatch!")

        # cleanup
        agent.remove_remote_agent("target")
        agent.release_xfer_handle(xfer_handle)
        agent.invalidate_local_metadata(target_ip, target_port)
        agent.deregister_memory(reg_descs)

        logger.info("=== INITIATOR DONE ===")
        sys.stdout.flush()
        os._exit(0)


    def main():
        print(f">>> main() called with args: {sys.argv}", flush=True)
        if len(sys.argv) < 4:
            print("Usage:")
            print("  Target:    python nixl-transfer-test.py target <listen_host> <listen_port>")
            print("  Initiator: python nixl-transfer-test.py initiator <target_host> <target_port>")
            sys.exit(1)

        mode = sys.argv[1]
        host = sys.argv[2]
        port = int(sys.argv[3])

        print(f">>> Running in {mode} mode", flush=True)
        if mode == "target":
            run_target(port)  # target only needs port
        elif mode == "initiator":
            run_initiator(host, port)
        else:
            print(f"Unknown mode: {mode}")
            sys.exit(1)


    if __name__ == "__main__":
        main()
