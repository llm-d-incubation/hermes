use anyhow::{Context, Result};
use clap::Parser;
use nix::sched::{CloneFlags, setns};
use roce_detector::{HcaDetail, RoceConfig, detect_roce_config};
use serde::Serialize;
use std::collections::HashMap;
use std::fs::File;
use tracing::info;

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about = "Detect and configure RoCE HCAs for NCCL, NVSHMEM, and UCX"
)]
struct Args {
    /// Output format: env (shell export), json, or quiet (env vars only)
    #[arg(short, long, default_value = "env")]
    format: OutputFormat,

    /// Filter HCAs by network interface name (comma-separated)
    #[arg(short = 'i', long)]
    socket_ifname: Option<String>,

    /// Force a specific GID index (overrides auto-detection)
    #[arg(short = 'g', long)]
    gid_index: Option<u32>,

    /// Device prefix to filter (e.g., "mlx5_", "mlx4_", "bnxt_")
    #[arg(short = 'p', long, default_value = "mlx5_")]
    device_prefix: String,

    /// Enter network namespace of specific PID before detection
    #[arg(long)]
    namespace_pid: Option<u32>,

    /// Namespace identifier for output correlation
    #[arg(long)]
    namespace_id: Option<String>,
}

#[derive(Debug, Clone, clap::ValueEnum)]
enum OutputFormat {
    /// Shell export statements
    Env,
    /// JSON output
    Json,
    /// Quiet mode - only env var values
    Quiet,
}

fn enter_network_namespace(pid: u32) -> Result<()> {
    let netns_path = format!("/proc/{}/ns/net", pid);
    let netns_file = File::open(&netns_path)
        .context(format!("Failed to open network namespace: {}", netns_path))?;

    setns(netns_file, CloneFlags::CLONE_NEWNET).context("Failed to enter network namespace")?;

    info!("Entered network namespace for PID {}", pid);
    Ok(())
}

fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(tracing::Level::INFO.into()),
        )
        .init();

    let args = Args::parse();

    // enter namespace if specified
    if let Some(pid) = args.namespace_pid {
        enter_network_namespace(pid)?;
    }

    let config = detect_roce_config(
        &args.device_prefix,
        args.socket_ifname.as_deref(),
        args.gid_index,
    )?;

    match args.format {
        OutputFormat::Env => print_env_output(&config),
        OutputFormat::Json => print_json_output(&config, args.namespace_id, args.namespace_pid)?,
        OutputFormat::Quiet => print_quiet_output(&config),
    }

    Ok(())
}

fn print_env_output(config: &RoceConfig) {
    println!("# RoCE HCA Configuration");
    println!("# Generated by roce-detector");
    println!();

    let nccl_hcas = config.nccl_hcas();
    if nccl_hcas.is_empty() {
        println!("# WARNING: No active RoCE HCAs found");
        return;
    }

    let nccl_hcas_str = nccl_hcas.join(",");
    let ucx_hcas_str = config.ucx_hcas().join(",");

    println!("export NCCL_IB_HCA=\"={}\"", nccl_hcas_str);
    println!("export NVSHMEM_HCA_LIST=\"{}\"", ucx_hcas_str);
    println!("export UCX_NET_DEVICES=\"{}\"", ucx_hcas_str);

    if let Some(gid_idx) = config.selected_gid_index() {
        println!();
        println!("export NCCL_IB_GID_INDEX=\"{}\"", gid_idx);
        println!("export NVSHMEM_IB_GID_INDEX=\"{}\"", gid_idx);
        println!("export UCX_IB_GID_INDEX=\"{}\"", gid_idx);
    }

    println!();
    println!("# Active HCAs: {}", config.active_hcas().join(", "));
}

fn print_json_output(
    config: &RoceConfig,
    namespace_id: Option<String>,
    namespace_pid: Option<u32>,
) -> Result<()> {
    // pivot to row format for reporting
    #[derive(Serialize)]
    struct JsonOutput {
        #[serde(skip_serializing_if = "Option::is_none")]
        namespace_id: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        namespace_pid: Option<u32>,
        active_hcas: Vec<String>,
        nccl_hcas: Vec<String>,
        ucx_hcas: Vec<String>,
        gid_index: Option<u32>,
        gid_index_counts: HashMap<u32, u32>,
        hca_details: Vec<HcaDetail>,
    }

    let output = JsonOutput {
        namespace_id,
        namespace_pid,
        active_hcas: config.active_hcas(),
        nccl_hcas: config.nccl_hcas(),
        ucx_hcas: config.ucx_hcas(),
        gid_index: config.selected_gid_index(),
        gid_index_counts: config.gid_index_counts(),
        hca_details: config.to_details(),
    };

    let json = serde_json::to_string_pretty(&output)?;
    println!("{}", json);
    Ok(())
}

fn print_quiet_output(config: &RoceConfig) {
    let nccl_hcas = config.nccl_hcas();
    if nccl_hcas.is_empty() {
        return;
    }

    let nccl_hcas_str = nccl_hcas.join(",");
    let ucx_hcas_str = config.ucx_hcas().join(",");

    println!("NCCL_IB_HCA=\"={}\"", nccl_hcas_str);
    println!("NVSHMEM_HCA_LIST=\"{}\"", ucx_hcas_str);
    println!("UCX_NET_DEVICES=\"{}\"", ucx_hcas_str);

    if let Some(gid_idx) = config.selected_gid_index() {
        println!("NCCL_IB_GID_INDEX=\"{}\"", gid_idx);
        println!("NVSHMEM_IB_GID_INDEX=\"{}\"", gid_idx);
        println!("UCX_IB_GID_INDEX=\"{}\"", gid_idx);
    }
}
